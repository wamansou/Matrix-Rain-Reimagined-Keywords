// Function to handle various property updates, such as text size, font, delay, etc.
function livelyPropertyListener(e, a) {
    switch (e) {
        case "textSize":
            fontSize = parseInt(a);
            columns = Math.floor(canvas.width / fontSize); // Recalculate the number of columns based on text size
            // Reinitialize drops and sequences
            initializeColumns();
            break;
        case "fontFamily":
            font = a; // Update font family
            break;
        case "fallingDelay":
            delay = parseInt(a); 
            if (timeoutId) {
                clearTimeout(timeoutId); // Clear existing timeout
                draw(); // Redraw the canvas with updated delay
            }
            break;
        case "rainingCharacters":
            letters = a.split(""); // Update characters that will rain
            // Regenerate sequences to apply the new letters
            for (var i = 0; i < columns; i++) {
                columnSequences[i] = generateColumnSequence();
            }
            break;
        case "rainingCharactersColor":
            primaryColor = a; // Update color for primary characters
            break;
        case "specialCharacters":
            specialLetters = a.split(""); // Update special characters
            break;
        case "specialCharactersColor":
            secondaryColor = a; // Update color for special characters
            break;
        case "isRainbowEnabled":
            isRainbowEnabled = a; // Toggle rainbow mode
            break;
        case "color1":
            rainbowColors[0] = a; // Update first color in the rainbow array
            break;
        case "color2":
            rainbowColors[1] = a; // Update second color in the rainbow array
            break;
        case "color3":
            rainbowColors[2] = a; // Update third color in the rainbow array
            break;
        case "color4":
            rainbowColors[3] = a; // Update fourth color in the rainbow array
            break;
        case "color5":
            rainbowColors[4] = a; // Update fifth color in the rainbow array
            break;
        case "color6":
            rainbowColors[5] = a; // Update sixth color in the rainbow array
            break;
        case "color7":
            rainbowColors[6] = a; // Update seventh color in the rainbow array
            break;
        case "highlightedWords":
            words = a.split(",").map(function(word) {
                return word.trim().toLowerCase();
            }); // Update the words to highlight
            wordsSet = new Set(words); // Update the Set for word matching
            maxWordLength = words.reduce(function(max, word) {
                return Math.max(max, word.length);
            }, 0); // Recalculate the maximum word length
            // Regenerate sequences to apply the new words
            for (var i = 0; i < columns; i++) {
                columnSequences[i] = generateColumnSequence();
            }
            break;
        case "highlightColor":
            highlightColor = a; // Update the highlight color
            break;
    }
}


// Canvas setup
var canvas = document.querySelector("canvas");
var ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Set up the characters and special characters
var letters = "abcdefghijklmnopqrstuvwxyz".split(""); // Use letters a-z
var specialLetters = []; // No special characters by default

// List of words to detect and highlight
var words = [
    "omg", "lol", "wtf", "lmao", "rofl", "brb", "idk", "btw", "bff", "imho"
];

// Convert words array to a Set for faster lookup
var wordsSet = new Set(words);

// Determine the maximum word length
var maxWordLength = words.reduce(function(max, word) {
    return Math.max(max, word.length);
}, 0);

// Initial settings for font size and columns
var fontSize = 14;
var columns = Math.floor(canvas.width / fontSize);

// Initialize drops array for each column
var drops = [];
var columnSequences = []; // Holds the letters and their highlight status for each column
var columnBuffers = [];   // Buffers for word matching in each column

function initializeColumns() {
    drops = [];
    columnSequences = [];
    columnBuffers = [];
    for (var i = 0; i < columns; i++) {
        drops[i] = 0; // Start at the top
        columnSequences[i] = generateColumnSequence();
        columnBuffers[i] = [];
    }
}

// Corrected function to generate a sequence of letters for a column, with highlighting
function generateColumnSequence() {
    var sequence = [];
    var buffer = [];
    // Generate enough letters to fill the screen several times
    var totalLetters = Math.floor(canvas.height / fontSize * 10);
    for (var i = 0; i < totalLetters; i++) {
        var a = letters[Math.floor(Math.random() * letters.length)];

        // Add the character to the sequence first
        sequence.push({
            char: a,
            highlight: false // Will be set to true if matched
        });

        // Update the buffer with the current character
        buffer.push(a);
        if (buffer.length > maxWordLength) {
            buffer.shift();
        }

        // Check for word matches
        var bufferString = buffer.join('');
        for (var len = 1; len <= buffer.length; len++) {
            var substring = bufferString.slice(-len);
            if (wordsSet.has(substring)) {
                // Mark the letters in the sequence for highlighting
                for (var j = i - len + 1; j <= i; j++) {
                    if (sequence[j]) {
                        sequence[j].highlight = true;
                    }
                }
                break; // Stop after first match
            }
        }
    }
    return sequence;
}

// Define initial settings for colors, delay, font, and rainbow settings
var timeoutId;
var primaryColor = "#00ff00"; // Default primary color (green)
var secondaryColor = "#ff0000"; // Default secondary color (red)
var delay = 40; // Delay between frames in milliseconds
var font = "Arial"; // Default font
var isRainbowEnabled = false; // Rainbow mode off by default
var rainbowColors = ["#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#0000ff", "#4b0082", "#9400d3"]; // Rainbow colors
var rainbowIndex = 0; // Initial index for rainbow colors

// Initialize columns
initializeColumns();

// Function to draw the matrix effect on the canvas
function draw() {
    // Set canvas background with slight transparency to create a fading effect
    ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Set the font and text alignment
    ctx.font = fontSize + "px " + font;
    ctx.textAlign = 'center'; // Center align text horizontally

    // Compute xOffset to center the columns
    var totalMatrixWidth = columns * fontSize;
    var xOffset = (canvas.width - totalMatrixWidth) / 2;

    // Loop through each column to draw the characters
    for (var e = 0; e < columns; e++) {
        // Get the next character from the sequence
        var drop = drops[e];
        var sequence = columnSequences[e];
        var index = Math.floor(drop);

        if (index >= sequence.length) {
            // Regenerate the sequence if we've reached the end
            sequence = columnSequences[e] = generateColumnSequence();
            index = 0;
            drop = drops[e] = 0;
        }

        var letterObj = sequence[index];
        var a = letterObj.char;
        var isHighlighted = letterObj.highlight;

        // Set the color for the character
        if (isHighlighted) {
            ctx.fillStyle = highlightColor; // Use the variable highlightColor
        } else {
            ctx.fillStyle = primaryColor;
            if (specialLetters.includes(a)) {
                ctx.fillStyle = secondaryColor; // Use secondary color for special characters
            }
            if (isRainbowEnabled) {
                ctx.fillStyle = rainbowColors[rainbowIndex]; // Use rainbow color if enabled
                rainbowIndex = (rainbowIndex + 1) % rainbowColors.length; // Cycle through rainbow colors
            }
        }

        // Calculate the x-coordinate centered in the column
        var x = e * fontSize + xOffset + fontSize / 2;

        // Draw the character at the correct position
        ctx.fillText(a, x, drop * fontSize);

        // Increment the drop position for the next frame
        drops[e] += 1;

        // If the drop reaches the bottom, randomly reset it
        if (drop * fontSize > canvas.height && Math.random() > 0.95) {
            drops[e] = 0;
            // Regenerate the sequence for variety
            columnSequences[e] = generateColumnSequence();
        }
    }

    // Set a timeout to call the draw function again based on the delay
    timeoutId = setTimeout(draw, parseInt(delay));
}


// Start the drawing process
draw();
